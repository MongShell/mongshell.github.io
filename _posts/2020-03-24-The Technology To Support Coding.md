---
title:  "코딩을 지탱하는 기술"
toc: true
toc_label: "Table of Contents"
toc_stick: true

categories:
  - Books
tags:
  - Language
---

<a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=31679090"><img src="https://image.aladin.co.kr/product/3167/90/cover500/8994774483_1.jpg" width="20%"></a>
---

### 리 뷰  

하나의 프로그래밍 언어에 대해 설명한 책은 많습니다. 그런 책들은 일반적으로 변수, 연산자, 조건문의 표현 방식 등 보편적인 내용으로 시작해서, 뒷부분에는 그 언어만의 특성에 대해 설명합니다.

그런데 여러 언어에 대해, 각 언어가 어떻게 분기문을 처리하고, 어떤 자료형을 가지며, 어떤 스코프 정책을 취하는가에 대한 책은 없을 겁니다. 언어가 너무 다양하고, 빠르게 변하기 때문입니다. 그리고 여러 언어를 그런 식으로 종합하는 것이 큰 의미가 없기도 합니다.

하지만 프로그래밍 언어의 세계에서 언제 분기문, 반복문이 등장했는지, 스코프에 대한 개념이 어떻게 발달했는지 이해하는 것은 유용합니다.  
프로그래밍 언어가 발전하고 개선되는 방식을 보고 프로그래밍 언어가 어떤 것인지 더 명확하게 알게됩니다. 그리고 각 언어의 특성을 파악하면서 특정 언어가 무슨 목적으로 그러한 특성을 갖게 됐는지 알 수 있습니다.

우리는 모두 처음 배운 프로그래밍 언어가 있습니다.
처음에는 그 언어의 참 거짓의 표현, 타입 종류, 분기문 처리, 에러 처리, 스코프 정책 등을 학습합니다.
그리고 좀 더 학습하다보면 다른 언어가 가지고 있지 않은 그 언어의 특성을 배우게 됩니다.
그 후, 우리가 다른 언어를 학습할 때 처음 배운 언어가 새로운 언어를 평가하는 기준이 됩니다.
이 언어는 이게 다르구나, 이렇게 하는구나, 이 점이 편하고, 저 점이 특이하구나 정도로 이해합니다. 이러한 과정은 서너가지 언어를 습득할 때까지 유지됩니다.  

이 책은 그런 방식에서 벗어나게 합니다.  
우선 유사한 기능을 다양한 언어들이 각자 어떻게 제공하는지 비교합니다. 그리고 해당 개념이 없던 시절의 언어와도 비교합니다.
예전에는 전혀 없던 기능이 생기게 된 이유와, 발전하는 과정을 설명합니다. 그리고 어떻게 자리잡아왔는지 보여줍니다.
제목 그대로 '코딩을 지탱하는 기술'들이 어떻게 진화했는지 보여줍니다.
그래서 이 책을 읽고 나면 프로그래밍 언어를 기존과 다른 관점으로 파악할 수 있습니다.
한가지 언어에 대해 알고 있는 것을 종단식 관점이라고 한다면 이 책은 횡단식 관점을 제시한다고 할 수 있습니다. 시간이라는 축까지 더해져 역사적 관점도 얻을 수 있습니다.

이 책의 서문을 보면 이 책에 주고자 한 관점이 소개되어 있습니다.

> 학습에는 3가지 중요한 포인트가 있다.
>
> - 비교를 통한 학습
> - 역사를 통한 학습
> - 만드는 것을 통한 학습
> 
> 첫 번째는 다수의 언어를 비교하는 것이다. 무엇이 그 언어만이 가진 특유의 개념이고, 무엇이 언어 간에 공통으로 사용되는 개념인지를 배울 수 있다.
> 두 번째는 언어의 발달 과정을 따라가는 것이다. 어떻게 탄생했고, 어떤 식으로 변화해 왔는지를 배움으로 ‘왜 이런 식으로 동작하고 있는지’에 대한 의문을 풀 수 있다.
> 세 번째는 직접 언어를 만드는 것이다. ‘나라면 어떻게 만들까?’를 생각함으로, 언어 설계자의 의도를 쉽게 이해할 수 있게 된다. 또한 실제로 만들어 봄으로써 자신이 잘 이해하지 못한 것을 알 수 있게 된다.

그리고 저 위의 세가지 학습 포인트 말고 끊임없이 강조하는 내용이 하나 더 있습니다.  
**규칙은 언어마다 다르다** 는 것입니다.  

이 책에 소개된 첫번째 예입니다.
>  C 언어에서는 0이 false 이지만, Ruby 에서는 true 이다.
>>  ```C
>>  #include <stdio.h>
>>  int main(){
>>    if(0){
>>      printf("true!\n");
>>    } else {
>>      printf("false!\n"); # false! 출력됨
>>    }
>>  }
>>  ```
>>  ```Ruby
>>  if 0 then
>>    print "true!"         # true! 출력됨
>>  else
>>    print "false!"
>>  end
>>  ```

다 읽고나니 저자가 목표한 것을 성공적으로 이뤘다고 생각됩니다.

이 책을 읽고 코딩실력이 나아지진 않습니다.
딱히 하나의 언어에 대해서 잘 알게 되지도 않습니다.
하지만 프로그래밍 언어를 바라보는 통찰을 얻을 수 있습니다.

많은 추천을 받아서 읽어보았는데, 책 두께에 비해 많은 시간을 쏟아 꼼꼼하게 읽은 책입니다.
사실 내리 2번 읽었습니다. 처음에는 감탄하면서 빠르게 읽었고, 두번째에는 하나라도 놓치지 않기 위해 정독했습니다.

결론은 이 책은 매우 훌륭하다는 것입니다.  
모든 프로그래머에게 추천합니다.


---
### 추천 대상   
모든 프로그래머

---
### 선행 요건
중간 이상으로 다룰 수 있는 언어가 최소 두 가지 이상   

---
#### 목 차

|1장 효율적으로 언어 배우기
|1.1 비교를 통한 배움
|- 규칙은 언어마다 다르다
|- C 언어와 Ruby의 참거짓 값
|- Java의 참거짓 값
|1.2 역사를 통한 배움
|- 언어 설계자의 의도를 이해하자
|- 어떤 언어를 배워야 하는지는 아무도 모른다
|- 언어에 의존하지 않는 보편적인 지식의 습득
|
|2장 프로그래밍 언어를 조감하다
|2.1 프로그래밍 언어 탄생의 역사
|- 케이블을 연결하다
|- 프로그램 내장 방식으로
|- FORTRAN의 등장
|2.2 프로그래밍 언어 탄생의 목적
|- 나태 - 프로그래머의 삼대 미덕
|- 언어에 따라 다른 ‘편리함’의 의미
|
|3장 문법의 탄생
|3.1 문법이란?
|- 연산자 우선순위
|- 문법은 언어 설계자가 정한 규칙
|3.2 스택 머신과 FORTH
|- 계산 순서
|- 연산 순서를 어떻게 표현할까?
|- 현재도 살아있는 스택 머신
|3.3 구문 트리와 LISP
|- 계산의 흐름
|- 계산 순서를 어떻게 표현할까?
|- 현재도 살아있는 구문 트리
|3.4 중위 표기법
|- 구문 해석기
|- 규칙간 마찰
|
|4장 처리 흐름 제어
|4.1 구조화 프로그래밍의 탄생
|4.2 if가 탄생하기 전
|- if는 왜 있는 걸까?
|- If-else는 왜 있는 걸까?
|4.3 while, 반복되는 if를 읽기 쉽게 표현
|- while 문을 사용하는 방법
|- while 문을 사용하지 않는 방법
|4.4 for, 수치를 증가시키는 while을 읽기 쉽게 표현
|- for를 사용하는 방법
|- for를 사용하지 않는 방법
|- foreach, 처리 대상으로 반복 제어
|
|5장 함수
|5.1 함수의 역할
|- 이해(조직을 예로)
|- 재사용(부품을 예로)
|- 프로그램 재사용의 특징
|5.2 돌아가는 명령
|- 함수의 탄생
|- 돌아갈 목적지를 기록하기 위한 전용 메모리
|- 스택
|5.3 재귀 호출
|- 내포 구조 데이터의 효율적 처리
|- 내포 구조를 다루는 방법
|
|6장 에러 처리
|6.1 프로그램도 실패를 한다
|6.2 실패를 어떻게 전달할까?
|- 반환값으로 실패를 전달한다
|- 실패하면 점프한다
|6.3 실패할 것 같은 처리를 묶는 구문
|- John Good enough의 주장
|- CLU에 도입
|- C++에 도입
|- Windows NT 3.1에 도입
|6.4 출구는 하나다
|- 왜 finally를 도입한 것일까?
|- 짝이 되는 처리를 반드시 실행한다
|6.5 어떤 경우에 예외를 던질까?
|- 함수 호출 시 인수가 부족한 경우
|- 배열 범위 밖에 있는 것을 취득하려고 했을 때
|- 틀리면 바로 예외를 던진다
|6.6 예외의 전파
|- 예외 전파의 문제점
|- Java의 검사 예외
|- 검사 예외가 잘 사용되지 않는 이유
|
|7장 이름과 스코프
|7.1 왜 이름이 필요할까?
|- 어떻게 이름을 붙일까?
|- 이름 충돌
|- 충돌 피하기
|7.2 스코프의 진화
|- 동적 스코프
|- 정적 스코프
|7.3 정적 스코프는 완성체인가?
|- 내포 함수의 문제점
|- 외부 스코프에 재귀속되는 문제
|
|8장 형
|8.1 형(型)이란?
|8.2 수치를 On과 Off로 표현하는 방법
|- 자릿수 발명
|- 7 세그먼트 디스플레이
|- 주판
|8.3 한 자리에 필요한 램프는 몇 개일까?
|- 10 진수에서 2 진수로
|- 8 진수와 16 진수
|8.4 실수는 어떻게 표현할까?
|- 고정 소수점 - 소수점을 어디에 붙일지 정한다
|- 부동 소수점 - 어디부터 소수부인지의 정보 자체를 값에 포함시킨다
|8.5 형은 무엇을 위해 존재할까?
|- 형이 없을 때 발생하는 문제
|- 초기 FORTRAN의 형
|- 언어 처리계에 변수 종류를 알린다
|- 암묵의 형 승격
|8.6 형의 다양한 전개
|- 사용자 정의형과 객체 지향
|- 사양으로서 형
|- 총칭형, 제네릭스, 템플릿
|- 동적 형결정
|- 형 추론
|
|9장 컨테이너와 문자열
|9.1 다양한 종류의 컨테이너
|9.2 왜 다양한 컨테이너가 존재할까?
|- 배열과 연결 리스트
|- 연결 리스트의 장단점
|- 언어에 따른 차이
|9.3 사전, 해쉬, 연상 배열
|- 해쉬 테이블
|- 트리
|- 요소를 꺼내는 시간
|- 만능 컨테이너란 없다
|9.4 문자란?
|- 문자 집합과 문자 부호화 방식
|- 컴퓨터 이전 시대의 부호화
|- EDSAC 문자 코드
|- ASCII와 EBCDIC 시대
|- Unicode에 의한 통일
|9.5 문자열이란?
|- 길이 정보를 가지고 있는 Pascal 문자열, 가지고 있지 않은 C 문자열
|- 한 문자가 16 비트인 Java 문자열
|- Python 3에서 이루어진 설계 변경
|- Ruby 1.9의 도전
|
|10장 병행 처리
|10.1 병행 처리란?
|10.2 잘게 분할해서 실행한다
|10.3 처리를 변경하는 2가지 방법
|- 협력적 멀티태스크
|- 선점적 멀티태스크 - 일정 시간에 교대한다
|10.4 경합 상태 방지법
|- 경합 상태의 3가지 조건
|- 공유하지 않는다 - 프로세스와 액터 모델
|- 변경하지 않는다 - const, val, Immutable
|- 끼어들지 않는다
|10.5 락의 문제점과 해결책
|- 락의 문제점
|- 트랜잭션 메모리
|- 트랜잭션 메모리의 역사
|트랜잭션 메모리는 성공할까?
|
|11장 객체와 클래스
|11.1 객체 지향이란?
|- 객체는 현실 세계의 모형
|- 클래스란?
|11.2 변수와 함수를 합쳐서 모형을 만드는 법
|11.3 방법 1: 모듈, 패키지
|- 모듈, 패키지란 무엇인가?
|- Perl 패키지로 객체를 만든다
|- 모듈만으로는 부족하다
|- 별도의 데이터 저장소를 만든다
|- 인수로 개별 해쉬를 전달한다
|- 초기화 처리도 패키지에 넣는다
|- 해쉬와 패키지를 연결한다
|11.4 방법 2: 함수도 해쉬에 넣는다
|- 퍼스트 클래스
|- 함수를 해쉬에 넣는다
|- 복수 개 카운터를 만든다
|- 공유하고 있는 사물을 프로토타입으로 이동한다
|- 이것이 객체 지향?
|11.5 방법 3: 클로저
|- 클로저란?
|- 왜 클로저라고 부를까?
|11.6 방법 4: 클래스
|- Hoare가 생각한 클래스
|- C++ 클래스
|- 사양으로서 역할
|- 클래스의 3가지 역할
|
|12장 상속을 통한 재사용
|12.1 상속이란?
|- 상속에 관한 다양한 접근법
|- 상속은 양날의 칼
|- 리스코프의 치환 원칙
|12.2 다중 상속
|- 하나의 사물을 복수로 분류
|- 코드 재사용에 편리한 다중 상속
|12.3 다중 상속의 문제점 - 거듭되는 충돌
|- 해결책 1: 다중 상속을 금지한다
|- 해결책 2: 메소드 해결 순서를 고민한다
|- 해결책 3: 처리를 섞는다
|- 해결책 4: 트레이트