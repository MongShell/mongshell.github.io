---
title:  "읽기 좋은 코드가 좋은 코드다"
toc: true
toc_label: "Table of Contents"
toc_stick: true

categories:
  - Books
tags:
  - Refactoring
  - Language
---

<a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=16108252"><img src="https://image.aladin.co.kr/product/1610/82/cover500/897914914x_1.jpg" width="20%"></a>
---

### 리 뷰  

'좋은 코드는 읽기 좋은 코드다.'
제가 정의하는 좋은 코드는 위와 같습니다.
같은 의미로 좋은 프로그래머는 읽기 좋은 코드를 작성하는 프로그래머입니다. 

그런데 '좋은 코드는 읽기 좋은 코드다.'라는 주장에 동의한다해도, '읽기 좋은' 이라는 기준은 모호합니다.
'짧은 코드가 좋은 코드다.'라고 한다면 라인 수로 평가가 되지만, '읽기 좋은'은 '좋은'처럼 평가가 어려운 단어입니다.

그래서 '읽기 좋은 코드'에 대한 많은 논의가 이루어졌습니다. 어느 정도의 보편적인 규칙과 합의가 나오게 되었고, 이를 소개한 고전 취급을 받는 책들도 있습니다.

이 책은 어떤 코드가 좋은 코드인지 기준을 세울 수 있도록 도와주는 책입니다. 기존의 책들과 특별히 다른 내용을 언급하지는 않습니다. 고개가 끄덕여지는 정도의 내용입니다. 하지만 이 책의 장점이라 한다면, '좋은 코드'에 대한 내용을 밀도있게 소개했다는 점입니다.  

예를 들면 다음과 같습니다. 

- 이름에 정보를 담아내라.

| 단어  |              대안                                  |
|-------|----------------------------------------------------|
| send  | deliver, dispatch, announce, distribute, route     |
| find  | search, extract, locate, recover                   |
| start | launch, create, begin, open                        |
| make  | create, set up, build, generate, compose, add, new |


그리고 아래의 목차를 보면 항목이 많고 구체적이라는 것을 알 수 있습니다. 각각에 긴 페이지를 할당하지 않아서, 빠르게 내용을 습득할 수 있습니다. 이런 류의 책은 컴퓨터 앞에서 연습을 요구하기도 하지만 이 책은 한 챕터를 가볍게 읽을 수 있습니다. 깊이는 조금 부족하지만 핵심은 짚고 넘어갑니다. 스타일의 차이라고 보시면 됩니다. 그래서 요점만 정리했기 때문에 여기에 소개된 기준들을 만족한 코드는 이미 일정 수준 이상이라고 할 수 있습니다. 

좋은 코드를 작성하는 기술을 습득하는 방식은 다양합니다. 많은 고민을 함으로써 조금씩 깨달을 수도 있고, 책을 통해서 습득하는 방식도 있습니다. 트레이닝을 통해서도 습득 가능하고, 좋은 선배 개발자나 코드 리뷰 문화에서 얻기도 합니다. 개발자들은 다양한 방식을 통해서 좋은 코드를 작성하는 기술을 습득하고 훈련하게 됩니다.

여담입니다만, 실무를 하다보면 기본적인 내용도 지켜지지 않은 코드도 많습니다. 이런 코드들을 보다보면 '작동한다 안한다'의 기준을 가지고 배포된 것이 아닐까 생각하게 됩니다. 이런 코드들은 동료들을 힘들게 하는 요소입니다. 이 책에 가볍게 소개된 수준의 것들만 지켜도 코드의 품질이 올라가고, 팀의 효율도 증가할 것입니다.  

---
### 추천 대상   
좋은 코드에 대한 기준을 가지지 못했거나, 기준을 가지고 있으나 정확히 표현하기 어려운 개발자

---
### 선행 요건
코드를 리팩토링 했을 때, 어떤 기준으로 하는 것이 좋을 지 고민해본 경험  

---
#### 목 차

|1장. 코드는 이해하기 쉬워야 한다
|- 01. 무엇이 코드를 '더 좋게' 만드는가?
|- 02. 가독성의 기본 정리
|- 03. 분량이 적으면 항상 더 좋은가?
|- 04. 이해를 위한 시간은 다른 목표와 충돌하는가?
|- 05. 어려운 부분
|
|PART I. 표면적 수준에서의 개선
|2장. 이름에 정보 담기
|- 01. 특정한 단어 고르기
|- 02. tmp나 retval 같은 보편적인 이름 피하기
|- 03. 추상적인 이름보다 구체적인 이름을 선호하라
|- 04. 추가적인 정보를 이름에 추가하기
|- 05. 이름은 얼마나 길어야 하는가?
|- 06. 이름 포메팅으로 의미를 전달하라
|
|3장. 오해할 수 없는 이름들
|- 01. 예: Filter()
|- 02. 예: Clip(text, length)
|- 03. 경계를 포함하는 한계값을 다룰 때는 min과 max를 사용하라
|- 04. 경계를 포함하는 범위에는 first와 last를 사용하라
|- 05. 경계를 포함하고/배제하는 범위에는 begin과 end를 사용하라
|- 06. 불리언 변수에 이름 붙이기
|- 07. 사용자의 기대에 부응하기
|- 08. 예: 이름을 짓기 위해서 복수의 후보를 평가하기
|
|4장. 미학
|- 01. 미학이 무슨 상관인가?
|- 02. 일관성과 간결성을 위해서 줄 바꿈을 재정렬하기
|- 03. 메소드를 활용하여 불규칙성을 정리하라
|- 04. 도움이 된다면 코드의 열을 맞춰라
|- 05. 의미 있는 순서를 선택하고 일관성 있게 사용하라
|- 06. 선언문을 블록으로 구성하라
|- 07. 코드를 '문단'으로 쪼개라
|- 08. 개인적인 스타일 대 일관성
|
|5장. 주석에 담아야 하는 대상
|- 01. 설명하지 말아야 하는 것
|- 02. 생각을 기록하라
|- 03. 코드를 읽는 사람의 입장이 되어라
|- 04. 마지막 고찰 - 글 쓰는 두려움을 떨쳐내라
|
|6장 명확하고 간결한 주석 달기
|- 01. 주석을 간결하게 하라
|- 02. 모호한 대명사는 피하라
|- 03. 엉터리 문장을 다듬어라
|- 04. 함수의 동작을 명확하게 설명하라
|- 05. 코너케이스를 설명해주는 입/출력 예를 사용하라
|- 06. 코드의 의도를 명시하라
|- 07. 이름을 가진 함수 파라미터 주석
|- 08. 정보 축약형 단어를 사용하라
|
|PART II. 루프와 논리를 단순화하기
|7장. 읽기 쉽게 흐름제어 만들기
|- 01. 조건문에서 인수의 순서
|- 02. if/else 블록의 순서
|- 03. (삼항 연산자로 알려진)?:를 이용하는 조건문 표현
|- 04. do/while 루프를 피하라
|- 05. 함수 중간에서 반환하기
|- 06. 악명 높은 goto
|- 07. 중첩을 최소화하기
|- 08. 실행 흐름을 따라올 수 있는가?
|
|8장. 거대한 표현을 잘게 쪼개기
|- 01. 설명 변수
|- 02. 요약 변수
|- 03. 드모르간의 법칙 사용하기
|- 04. 쇼트 서킷 논리 오용하기
|- 05. 예: 복잡한 논리와 씨름하기
|- 06. 거대한 구문 나누기
|- 07. 표현을 단순화하는 다른 창의적인 방법들
|
|9장. 변수와 가독성
|- 01. 변수 제거하기
|- 02. 변수의 범위를 좁혀라
|- 03. 값을 한 번만 할당하는 변수를 선호하라
|- 04. 마지막 예
|
|PART III. 코드 재작성하기
|10장. 상관없는 하위문제 추출하기
|- 01. 소개를 위한 예: findClosestLocation()
|- 02. 순수한 유틸리티 코드
|- 03. 일반적인 목적의 코드
|- 04. 일반적인 목적을 가진 코드를 많이 만들어라
|- 05. 특정한 프로젝트를 위한 기능
|- 06. 기존의 인터페이스를 단순화하기
|- 07. 자신의 필요에 맞춰서 인터페이스의 형태를 바꾸기
|- 08. 지나치게 추출하기
|
|11장. 한 번에 하나씩
|- 01. 작업은 작을 수 있다
|- 02. 객체에서 값 추출하기
|- 03. 더 큰 예제
|
|12장. 생각을 코드로 만들기
|- 01. 논리를 명확하게 설명하기
|- 02. 라이브러리를 알면 도움이 된다
|- 03. 논리를 쉬운 말로 표현하는 방법을 더 큰 문제에 적용하기
|
|13장. 코드 분량 줄이기
|- 01. 그 기능을 구현하려고 애쓰지 마라 - 그럴 필요가 없다
|- 02. 요구사항에 질문을 던지고 질문을 잘게 나누어 분석하라
|- 03. 코드베이스를 작게 유지하기
|- 04. 자기 주변에 있는 라이브러리에 친숙해져라
|- 05. 예: 코딩 대신 유닉스 도구를 활용하기
|
|PART IV. 선택된 주제들
|- 14장. 테스트와 가독성
|- 01. 읽거나 유지보수하기 쉽게 테스트를 만들어라
|- 02. 이 테스트는 어떤 점이 잘못되었을까?
|- 03. 이 테스트를 더 읽기 쉽게 만들기
|- 04. 읽기 편한 메시지 만들기
|- 05. 좋은 테스트 입력값의 선택
|- 06. 테스트 함수에 이름 붙이기
|- 07. 이 테스트 코드는 무엇이 잘못되었는가?
|- 08. 테스트에 친숙한 개발
|- 09. 지나친 테스트
|
|15장. '분/시간 카운터'를 설계하고 구현하기
|- 01. 문제
|- 02. 클래스 인터페이스 정의하기
|- 03. 시도1: 순진한 해결책
|- 04. 시도2: 컨베이어 벨트 설계
|- 05. 시도3: 시간-바구니 설계
|- 06. 3가지 해결책 비교하기
|
|Appendix 추가적인 도서목록
|- 01. 높은 수준의 코드를 쓰는 방법을 다루는 책들
|- 02. 다양한 프로그래밍 주제에 대한 책들
|- 03. 역사적 사례를 담고 있는 책들